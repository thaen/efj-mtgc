<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<link rel="icon" href="/static/favicon.ico" type="image/x-icon">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Collection Browser</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/keyrune@latest/css/keyrune.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mana-font@latest/css/mana.min.css">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  background: #1a1a2e;
  color: #e0e0e0;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  min-height: 100vh;
}

header {
  background: #16213e;
  padding: 16px 24px;
  display: flex;
  align-items: center;
  gap: 16px;
  flex-wrap: wrap;
  border-bottom: 2px solid #0f3460;
}

header h1 {
  font-size: 1.3rem;
  color: #e94560;
  margin-right: 16px;
  white-space: nowrap;
}

.controls {
  display: flex;
  align-items: center;
  gap: 10px;
  flex-wrap: wrap;
}

input[type="text"], select, button {
  padding: 8px 14px;
  border: 1px solid #0f3460;
  border-radius: 6px;
  background: #1a1a2e;
  color: #e0e0e0;
  font-size: 0.9rem;
}

input[type="text"]:focus, select:focus { outline: 2px solid #e94560; }

button {
  background: #e94560;
  border-color: #e94560;
  color: #fff;
  font-weight: 600;
  cursor: pointer;
}

button:hover { background: #c73651; }

button.secondary {
  background: #333;
  border-color: #555;
}
button.secondary:hover { background: #e94560; border-color: #e94560; }
button.secondary.active { background: #0f3460; border-color: #e94560; }

#search-input { width: 220px; }

#status {
  font-size: 0.85rem;
  color: #888;
  margin-left: auto;
}

/* Layout */
.layout {
  display: flex;
  min-height: calc(100vh - 70px);
}

/* Sidebar (slide-in panel from left) */
.sidebar-backdrop {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.4);
  z-index: 90;
}
.sidebar-backdrop.active { display: block; }

.sidebar {
  position: fixed;
  top: 0; left: -320px;
  width: 300px;
  height: 100vh;
  background: #16213e;
  border-right: 2px solid #0f3460;
  padding: 16px;
  overflow-y: auto;
  z-index: 91;
  transition: left 0.25s ease;
  box-shadow: 4px 0 20px rgba(0,0,0,0.5);
}

.sidebar.open { left: 0; }

.sidebar h3 {
  font-size: 0.85rem;
  color: #888;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin: 16px 0 8px;
}

.sidebar h3:first-child { margin-top: 0; }

/* Pill groups */
.pill-group { display: flex; flex-wrap: wrap; gap: 4px; }
.pill-group input[type="checkbox"] { display: none; }
.pill-group label {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 4px 12px;
  border: 1px solid #0f3460;
  border-radius: 20px;
  font-size: 0.8rem;
  cursor: pointer;
  transition: background 0.15s, border-color 0.15s;
  user-select: none;
}
.pill-group label:hover { border-color: #e94560; }
.pill-group input[type="checkbox"]:checked + label {
  background: #e94560;
  border-color: #e94560;
  color: #fff;
}

/* Color pill mana icons */
.pill-group label .ms { font-size: 1rem; }

/* Rarity dots */
.rarity-dot {
  display: inline-block;
  width: 10px;
  height: 10px;
  border-radius: 50%;
  flex-shrink: 0;
}

/* Multi-select search component */
.multi-select-wrap { position: relative; }
.multi-search-input {
  width: 100%;
  padding: 6px 10px;
  border: 1px solid #0f3460;
  border-radius: 4px;
  background: #1a1a2e;
  color: #e0e0e0;
  font-size: 0.85rem;
}
.multi-search-input:focus { outline: 2px solid #e94560; }
.multi-dropdown {
  display: none;
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  max-height: 200px;
  overflow-y: auto;
  background: #1a1a2e;
  border: 1px solid #0f3460;
  border-top: none;
  border-radius: 0 0 4px 4px;
  z-index: 50;
  list-style: none;
}
.multi-dropdown.open { display: block; }
.multi-dropdown li {
  padding: 6px 10px;
  font-size: 0.85rem;
  cursor: pointer;
}
.multi-dropdown li:hover { background: #0f3460; }
.multi-dropdown li.selected { color: #e94560; }
.selected-pills {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
  margin-top: 4px;
}
.selected-pill {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 2px 8px;
  background: #0f3460;
  border: 1px solid #e94560;
  border-radius: 12px;
  font-size: 0.75rem;
  color: #e0e0e0;
}
.selected-pill .remove-pill {
  cursor: pointer;
  color: #e94560;
  font-weight: bold;
  font-size: 0.85rem;
  line-height: 1;
}
.selected-pill .remove-pill:hover { color: #fff; }

/* Range filter inputs */
.range-row {
  display: flex;
  gap: 6px;
  align-items: center;
}
.range-row input[type="number"], .range-row input[type="date"] {
  width: 60px;
  padding: 4px 6px;
  border: 1px solid #0f3460;
  border-radius: 4px;
  background: #1a1a2e;
  color: #e0e0e0;
  font-size: 0.8rem;
}
.range-row input[type="date"] { width: auto; }
.range-row input[type="date"]::-webkit-calendar-picker-indicator { filter: invert(0.7); }
.range-row input[type="number"]:focus, .range-row input[type="date"]:focus { outline: 2px solid #e94560; }
.range-row span { font-size: 0.8rem; color: #888; }

/* Main content */
.main {
  flex: 1;
  padding: 4px;
  overflow-y: auto;
}

/* Table view */
.collection-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.85rem;
}

.collection-table th {
  text-align: left;
  padding: 8px 12px;
  border-bottom: 2px solid #0f3460;
  color: #888;
  font-weight: 600;
  cursor: pointer;
  user-select: none;
  white-space: nowrap;
}

.collection-table th:hover { color: #e94560; }
.collection-table th.sorted { color: #e94560; }

.collection-table td {
  padding: 2px 12px;
  border-bottom: 1px solid #0f346033;
  vertical-align: middle;
}

.collection-table tr:hover { background: rgba(15, 52, 96, 0.2); }
.collection-table tr { cursor: pointer; }

.card-cell {
  display: flex;
  align-items: center;
  gap: 10px;
}

.card-thumb {
  width: 146px;
  height: 44px;
  object-fit: cover;
  object-position: top center;
  border-radius: 4px;
  flex-shrink: 0;
}

.card-name { font-weight: 500; margin-right: 1em; }

.type-cell {
  max-width: 160px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  line-height: 1.3;
}
.type-sub {
  display: block;
  font-size: 0.8em;
  color: #777;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.mana-cost { white-space: nowrap; }
.mana-cost .ms { font-size: 0.85rem; }
.mana-line { display: block; white-space: nowrap; }

.card-face { display: block; }
.card-face + .card-face { margin-top: 2px; }

.set-cell { display: flex; align-items: center; gap: 6px; white-space: nowrap; }
.set-cell .ss {
  font-size: 2.0em;
  width: 40px;
  height: 40px;
  line-height: 40px;
  text-align: center;
  -webkit-text-stroke: 3px rgba(0,0,0,0.85);
  paint-order: stroke fill;
}
.set-cell .ss.ss-grad::before {
  -webkit-text-fill-color: currentColor;
}
.set-cell .ss.ss-common {
  -webkit-text-stroke: 2px rgba(255,255,255,0.9);
}

.price-cell { white-space: nowrap; color: #aaa; font-variant-numeric: tabular-nums; }

/* Card grid */
.card-grid {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
}

.sheet-card {
  width: var(--grid-card-width, 264px);
  position: relative;
  cursor: pointer;
}

.sheet-card-img-wrap {
  width: var(--grid-card-width, 264px);
  aspect-ratio: 488 / 680;
  border-radius: 8px;
  position: relative;
  overflow: hidden;
  --rarity-color: #111;
  --set-color: #111;
  background: linear-gradient(to bottom, var(--rarity-color), var(--set-color));
}

.sheet-card-img-wrap img {
  position: absolute;
  top: 2px; left: 2px;
  width: calc(100% - 4px);
  height: calc(100% - 4px);
  object-fit: cover;
  border-radius: 6px;
  image-rendering: high-quality;
}

.sheet-card-img-wrap.foil::before {
  content: "";
  position: absolute;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background: repeating-linear-gradient(
    135deg,
    rgba(255,0,0,0.08),
    rgba(255,165,0,0.08) 5%,
    rgba(255,255,0,0.08) 10%,
    rgba(0,200,0,0.08) 15%,
    rgba(0,140,255,0.08) 20%,
    rgba(130,0,255,0.08) 25%,
    rgba(255,0,200,0.08) 30%,
    rgba(255,0,0,0.08) 33.33%
  );
  mix-blend-mode: color;
  pointer-events: none;
  z-index: 1;
}

.sheet-card-img-wrap.foil::after {
  content: "";
  position: absolute;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background:
    linear-gradient(135deg, transparent 46%, rgba(255,255,255,0.12) 49%, rgba(255,255,255,0.12) 51%, transparent 54%)
    100% 100% / 240% 240%;
  pointer-events: none;
  z-index: 2;
  animation: foil-streak 3s ease-in-out infinite;
}

@keyframes foil-streak {
  0% { background-position: 100% 100%; }
  15%, 100% { background-position: 0 0; }
}


.qty-badge {
  position: absolute;
  top: 6px; right: 6px;
  background: rgba(233, 69, 96, 0.9);
  color: #fff;
  font-size: 0.75rem;
  font-weight: 700;
  padding: 2px 7px;
  border-radius: 10px;
  z-index: 3;
}

.badge {
  font-size: 0.6rem;
  font-weight: 700;
  padding: 1px 5px;
  border-radius: 3px;
  text-transform: uppercase;
}

.badge.treatment { background: linear-gradient(135deg, #0f2a3e, #0f3460); border: 1px solid #1a5276; color: #7ec8e3; }
a.badge.link { background: #333; border: 1px solid #555; color: #aaa; text-decoration: none; font-variant-numeric: tabular-nums; white-space: nowrap; }
a.badge.link:hover { color: #fff; background: #555; border-color: #777; }

.foil-tag, .treat-tag, .promo-tag {
  display: inline-block;
  padding: 2px 6px;
  border-radius: 3px;
  font-size: 0.7rem;
  font-weight: 700;
}

.foil-tag {
  background: linear-gradient(135deg, #2a1a3e, #1a2a4e);
  border: 1px solid #5c2d91;
  color: #c8a0e8;
}

.treat-tag {
  background: linear-gradient(135deg, #0f2a3e, #0f3460);
  border: 1px solid #1a5276;
  color: #7ec8e3;
}

.promo-tag {
  background: linear-gradient(135deg, #3e2a0f, #4e3a1a);
  border: 1px solid #76521a;
  color: #e3c87e;
}

.card-tag {
  padding: 1px 3px;
  font-size: 0.6rem;
  vertical-align: middle;
  margin-left: 0px;
}

.empty-state {
  color: #555;
  font-style: italic;
  font-size: 0.9rem;
  padding: 32px;
  text-align: center;
}

/* Card detail modal */
#card-modal-overlay {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.8);
  z-index: 100;
  justify-content: center;
  align-items: center;
}

#card-modal-overlay.active { display: flex; }

.card-modal {
  background: #16213e;
  border-radius: 16px;
  box-shadow: 0 12px 40px rgba(0,0,0,0.8);
  display: flex;
  gap: 0;
  max-height: 90vh;
  max-width: 90vw;
  overflow: hidden;
}

.card-modal-img {
  flex-shrink: 0;
  display: flex;
  align-items: center;
  background: #0a0a1a;
  padding: 16px;
  perspective: 1200px;
  position: relative;
}

.card-flip-container {
  transform-style: preserve-3d;
  transition: transform 0.6s;
}

.card-flip-container.flipped { transform: rotateY(180deg); }

.card-flip-front, .card-flip-back {
  backface-visibility: hidden;
}

.card-flip-back {
  position: absolute;
  top: 0; left: 0;
  transform: rotateY(180deg);
}

.card-flip-front img, .card-flip-back img {
  height: 72vh;
  border-radius: 12px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.6);
  display: block;
}

.flip-btn {
  position: absolute;
  bottom: 24px;
  right: 24px;
  width: 36px;
  height: 36px;
  border-radius: 50%;
  background: rgba(0,0,0,0.7);
  border: 1px solid #555;
  color: #e0e0e0;
  font-size: 1.2rem;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 5;
  padding: 0;
}

.flip-btn:hover { background: rgba(233,69,96,0.8); border-color: #e94560; }

.card-modal-details {
  width: 320px;
  padding: 24px;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.card-modal-details h2 {
  font-size: 1.2rem;
  color: #fff;
  margin: 0;
  line-height: 1.3;
}

.modal-section {
  display: flex;
  flex-direction: column;
  gap: 6px;
  padding: 8px 0;
}

.modal-section-title {
  font-size: 0.7rem;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: #666;
  font-weight: 600;
}

.modal-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 0.85rem;
}

.modal-row .label { color: #888; }
.modal-row .value { color: #e0e0e0; font-weight: 500; }
.modal-row .value a { color: #7ec8e3; text-decoration: none; }
.modal-row .value a:hover { text-decoration: underline; }

.modal-mana { margin-top: 2px; }
.modal-mana .ms { font-size: 1rem; }

.modal-tags {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
}

.modal-links {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
}

.modal-links a.badge.link {
  font-size: 0.75rem;
  padding: 3px 8px;
}

a.lineage-link {
  display: block;
  margin-top: 8px;
  font-size: 0.75rem;
  color: #7ec8e3;
  text-decoration: underline;
}

.modal-close {
  position: absolute;
  top: 12px;
  right: 16px;
  background: none;
  border: none;
  color: #666;
  font-size: 1.5rem;
  cursor: pointer;
  padding: 4px 8px;
  line-height: 1;
}
.modal-close:hover { color: #e94560; background: none; }

@media (max-width: 768px) {
  .card-modal { flex-direction: column; max-height: 95vh; }
  .card-flip-front img, .card-flip-back img { height: auto; width: 70vw; }
  .card-modal-details { width: auto; }
}

/* Column config dropdown */
.col-config-wrap { position: relative; }
.col-config-dropdown {
  display: none;
  position: absolute;
  top: 100%;
  right: 0;
  background: #16213e;
  border: 1px solid #0f3460;
  border-radius: 6px;
  padding: 6px 0;
  z-index: 60;
  min-width: 160px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
}
.col-config-dropdown.open { display: block; }
.col-config-dropdown label {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 5px 14px;
  font-size: 0.82rem;
  cursor: pointer;
  white-space: nowrap;
}
.col-config-dropdown label:hover { background: #0f3460; }
.col-config-dropdown input[type="checkbox"] { accent-color: #e94560; }

/* Sort arrow */
.sort-arrow { font-size: 0.7rem; margin-left: 2px; }

/* Sort bar (grid view) */
.sort-bar {
  display: flex;
  gap: 4px;
  flex-wrap: wrap;
  margin-bottom: 12px;
}

.sort-btn {
  padding: 4px 10px;
  border: 1px solid #0f3460;
  border-radius: 4px;
  background: #16213e;
  color: #888;
  font-size: 0.8rem;
  font-weight: 600;
  cursor: pointer;
  user-select: none;
  white-space: nowrap;
}

.sort-btn:hover { color: #e94560; border-color: #e94560; }
.sort-btn.active { color: #e94560; border-color: #e94560; background: #1a1a2e; }

.size-slider-wrap {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 0.8rem;
  color: #888;
}

.size-slider-wrap input[type="range"] {
  width: 100px;
  accent-color: #e94560;
}

.filterable { cursor: pointer; }
.filterable:hover { text-decoration: underline; text-decoration-color: #e94560; }

/* More dropdown menu items */
.menu-item {
  display: block;
  width: 100%;
  padding: 6px 14px;
  font-size: 0.82rem;
  cursor: pointer;
  white-space: nowrap;
  background: none;
  border: none;
  color: #e0e0e0;
  text-align: left;
  font-weight: 400;
}
.menu-item:hover { background: #0f3460; }

/* Selection bar */
.selection-bar {
  display: none;
  align-items: center;
  gap: 12px;
  padding: 8px 24px;
  background: #0f3460;
  border-bottom: 1px solid #1a5276;
  font-size: 0.85rem;
  color: #e0e0e0;
}
.selection-bar.active { display: flex; }
.selection-bar .sel-count { font-weight: 600; }
.selection-bar .sel-link {
  color: #e94560;
  cursor: pointer;
  text-decoration: underline;
  background: none;
  border: none;
  font-size: 0.85rem;
  padding: 0;
}
.selection-bar .sel-link:hover { color: #fff; }
.selection-bar .sel-actions { margin-left: auto; display: flex; align-items: center; gap: 10px; }
.sel-share-link { color: #7ec8e3; text-decoration: underline; font-size: 0.85rem; }
.sel-share-link:hover { color: #fff; }

/* Select column in table */
.select-col { width: 32px; text-align: center; }
.select-col input[type="checkbox"] { accent-color: #e94560; cursor: pointer; }

/* Selected row highlight */
.collection-table tr.selected { background: rgba(233, 69, 96, 0.1); }
.collection-table tr.selected:hover { background: rgba(233, 69, 96, 0.18); }

/* Select checkbox on grid cards */
.select-checkbox {
  position: absolute;
  top: 8px;
  left: 8px;
  z-index: 4;
  accent-color: #e94560;
  width: 16px;
  height: 16px;
  cursor: pointer;
}

.sheet-card.unowned .sheet-card-img-wrap {
  filter: grayscale(85%) brightness(0.55);
  opacity: 0.6;
}
.sheet-card.unowned .sheet-card-img-wrap.foil::before,
.sheet-card.unowned .sheet-card-img-wrap.foil::after {
  display: none;
}
tr.unowned td { opacity: 0.45; }
tr.unowned.wanted td { opacity: 0.7; }

/* Ordered rows in list view */
tr.ordered td { opacity: 0.7; }
tr.ordered td:first-child { border-left: 3px solid #f0a030; }

/* Ordered indicator on grid cards */
.ordered-badge {
  position: absolute;
  bottom: 6px; left: 6px;
  width: 8px; height: 8px;
  border-radius: 50%;
  background: #f0a030;
  box-shadow: 0 0 4px rgba(240, 160, 48, 0.6);
  pointer-events: none;
}

/* Ordered grid card image */
.sheet-card.ordered .sheet-card-img-wrap {
  filter: brightness(0.8);
  opacity: 0.8;
}

/* Wanted badge on grid cards */
.wanted-badge {
  position: absolute;
  top: 6px; left: 6px;
  background: rgba(42, 140, 90, 0.9);
  color: #7ee8b0;
  font-size: 0.65rem;
  font-weight: 700;
  padding: 2px 6px;
  border-radius: 10px;
  z-index: 3;
  text-transform: uppercase;
  letter-spacing: 0.03em;
}

.sheet-card.unowned.wanted .sheet-card-img-wrap {
  filter: grayscale(30%) brightness(0.75);
  opacity: 0.85;
}

/* Wanted inline tag for table */
.card-tag.wanted-tag {
  background: #1a5c3a;
  border: 1px solid #2a8c5a;
  color: #7ee8b0;
}
/* Ordered inline tag for table */
.card-tag.ordered-tag {
  background: #5c3a1a;
  border: 1px solid #8c5a2a;
  color: #f0c878;
}
#include-unowned-btn.active {
  background: #e94560;
  color: #fff;
}
#include-unowned-btn:disabled {
  opacity: 0.35;
  cursor: not-allowed;
}

/* Want button in modal */
.want-btn {
  padding: 3px 10px;
  border-radius: 3px;
  font-size: 0.75rem;
  font-weight: 700;
  cursor: pointer;
  border: 1px solid #555;
  background: #333;
  color: #aaa;
}
.want-btn:hover { color: #fff; background: #555; border-color: #777; }
.want-btn.wanted {
  background: #1a5c3a;
  border-color: #2a8c5a;
  color: #7ee8b0;
}
.want-btn.wanted:hover { background: #c73651; border-color: #e94560; color: #fff; }

/* Wishlist panel */
.wishlist-backdrop {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.4);
  z-index: 90;
}
.wishlist-backdrop.active { display: block; }

.wishlist-panel {
  position: fixed;
  top: 0; right: -340px;
  width: 320px;
  height: 100vh;
  background: #16213e;
  border-left: 2px solid #0f3460;
  z-index: 91;
  display: flex;
  flex-direction: column;
  transition: right 0.25s ease;
  box-shadow: -4px 0 20px rgba(0,0,0,0.5);
}
.wishlist-panel.open { right: 0; }

.wishlist-panel-header {
  padding: 16px;
  border-bottom: 1px solid #0f3460;
  display: flex;
  align-items: center;
  justify-content: space-between;
  flex-shrink: 0;
}
.wishlist-panel-header h3 { font-size: 1rem; color: #e0e0e0; }

.wishlist-panel-list {
  flex: 1;
  overflow-y: auto;
  padding: 8px;
}

.wl-entry {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 8px;
  border-radius: 4px;
  font-size: 0.82rem;
}
.wl-entry:hover { background: rgba(15,52,96,0.3); }
.wl-entry .wl-name { flex: 1; color: #e0e0e0; }
.wl-entry .wl-set { color: #888; font-size: 0.75rem; }
.wl-entry .wl-remove {
  background: none;
  border: none;
  color: #666;
  cursor: pointer;
  font-size: 1rem;
  padding: 0 4px;
  line-height: 1;
}
.wl-entry .wl-remove:hover { color: #e94560; }

.wishlist-panel-footer {
  padding: 12px;
  border-top: 1px solid #0f3460;
  display: flex;
  flex-direction: column;
  gap: 6px;
  flex-shrink: 0;
}
.wishlist-panel-footer button { font-size: 0.82rem; padding: 6px 12px; }

.wl-cart-row { display: flex; gap: 6px; }
.wl-cart-row button { flex: 1; }

/* Buy Missing dropdown */
.buy-missing-wrap { position: relative; display: none; }
.buy-missing-wrap.visible { display: inline-block; }
.buy-missing-dropdown {
  display: none;
  position: absolute;
  top: 100%;
  right: 0;
  background: #16213e;
  border: 1px solid #0f3460;
  border-radius: 6px;
  padding: 4px 0;
  z-index: 60;
  min-width: 170px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
}
.buy-missing-dropdown.open { display: block; }

@media (max-width: 768px) {
  #search-input { width: 140px; }
  .sidebar { width: 280px; left: -300px; }
  .wishlist-panel { width: 280px; right: -300px; }
}
</style>
<style id="dynamic-settings-style"></style>
</head>
<body>

<header>
  <h1><a href="/" style="color:inherit;text-decoration:none">Collection</a></h1>
  <div class="controls">
    <input type="text" id="search-input" placeholder="Search cards...">
    <button class="secondary" id="view-table-btn" title="Table view">Table</button>
    <button class="secondary" id="view-grid-btn" title="Grid view">Grid</button>
    <button class="secondary" id="sidebar-toggle-btn" title="Toggle filters">Filters</button>
    <div class="col-config-wrap">
      <button class="secondary" id="col-config-btn" title="Configure columns">Columns</button>
      <div class="col-config-dropdown" id="col-config-dropdown"></div>
    </div>
    <div class="col-config-wrap">
      <button class="secondary" id="more-menu-btn">More</button>
      <div class="col-config-dropdown" id="more-menu-dropdown">
        <button class="menu-item" id="toggle-multiselect-btn">Toggle Multi-Select</button>
      </div>
    </div>
    <button class="secondary" id="include-unowned-btn" disabled title="Select a set first">+ Unowned</button>
    <div class="buy-missing-wrap" id="buy-missing-wrap">
      <button class="secondary" id="buy-missing-btn">Buy Missing</button>
      <div class="buy-missing-dropdown" id="buy-missing-dropdown">
        <button class="menu-item" id="buy-missing-ck">Copy for Card Kingdom</button>
        <button class="menu-item" id="buy-missing-tcg">Copy for TCGplayer</button>
      </div>
    </div>
    <button class="secondary" id="wishlist-toggle-btn">Wishlist (0)</button>
    <div class="size-slider-wrap" id="grid-size-wrap" style="display:none"><span>Size</span><input type="range" id="grid-size-slider" min="100" max="500" value="264"></div>
  </div>
  <div id="status"></div>
</header>

<div class="selection-bar" id="selection-bar">
  <span class="sel-count" id="sel-count">0 selected</span>
  (<button class="sel-link" id="sel-all">All</button> / <button class="sel-link" id="sel-none">None</button>)
  <div class="sel-actions">
    <span id="sel-share-result"></span>
    <button id="sel-want-btn">Want</button>
    <button id="sel-share-btn">Share</button>
  </div>
</div>

<div class="sidebar-backdrop" id="sidebar-backdrop"></div>
<div class="layout">
  <aside class="sidebar" id="sidebar">
    <h3>Color</h3>
    <div class="pill-group" id="color-filters">
      <input type="checkbox" id="cf-W" value="W"><label for="cf-W"><i class="ms ms-w ms-cost"></i></label>
      <input type="checkbox" id="cf-U" value="U"><label for="cf-U"><i class="ms ms-u ms-cost"></i></label>
      <input type="checkbox" id="cf-B" value="B"><label for="cf-B"><i class="ms ms-b ms-cost"></i></label>
      <input type="checkbox" id="cf-R" value="R"><label for="cf-R"><i class="ms ms-r ms-cost"></i></label>
      <input type="checkbox" id="cf-G" value="G"><label for="cf-G"><i class="ms ms-g ms-cost"></i></label>
      <input type="checkbox" id="cf-C" value="C"><label for="cf-C"><i class="ms ms-c ms-cost"></i></label>
    </div>

    <h3>Rarity</h3>
    <div class="pill-group" id="rarity-filters">
      <input type="checkbox" id="rf-common" value="common"><label for="rf-common"><span class="rarity-dot" style="background:#111"></span> C</label>
      <input type="checkbox" id="rf-uncommon" value="uncommon"><label for="rf-uncommon"><span class="rarity-dot" style="background:#6a6a6a"></span> U</label>
      <input type="checkbox" id="rf-rare" value="rare"><label for="rf-rare"><span class="rarity-dot" style="background:#c9a816"></span> R</label>
      <input type="checkbox" id="rf-mythic" value="mythic"><label for="rf-mythic"><span class="rarity-dot" style="background:#d4422a"></span> M</label>
    </div>

    <h3>Set</h3>
    <div class="multi-select-wrap" id="set-filter-wrap">
      <input type="text" class="multi-search-input" id="set-search" placeholder="Search sets..." autocomplete="off">
      <ul class="multi-dropdown" id="set-dropdown"></ul>
      <div class="selected-pills" id="set-pills"></div>
    </div>

    <h3>Type</h3>
    <div class="pill-group" id="type-filters">
      <input type="checkbox" id="tf-creature" value="Creature"><label for="tf-creature">Creature</label>
      <input type="checkbox" id="tf-instant" value="Instant"><label for="tf-instant">Instant</label>
      <input type="checkbox" id="tf-sorcery" value="Sorcery"><label for="tf-sorcery">Sorcery</label>
      <input type="checkbox" id="tf-enchantment" value="Enchantment"><label for="tf-enchantment">Enchantment</label>
      <input type="checkbox" id="tf-artifact" value="Artifact"><label for="tf-artifact">Artifact</label>
      <input type="checkbox" id="tf-planeswalker" value="Planeswalker"><label for="tf-planeswalker">PW</label>
      <input type="checkbox" id="tf-land" value="Land"><label for="tf-land">Land</label>
      <input type="checkbox" id="tf-battle" value="Battle"><label for="tf-battle">Battle</label>
      <input type="checkbox" id="tf-kindred" value="Kindred"><label for="tf-kindred">Kindred</label>
      <input type="checkbox" id="tf-token" value="Token"><label for="tf-token">Token</label>
    </div>

    <h3>Subtype</h3>
    <div class="multi-select-wrap" id="subtype-filter-wrap">
      <input type="text" class="multi-search-input" id="subtype-search" placeholder="Search subtypes..." autocomplete="off">
      <ul class="multi-dropdown" id="subtype-dropdown"></ul>
      <div class="selected-pills" id="subtype-pills"></div>
    </div>

    <h3>Collector #</h3>
    <div class="range-row">
      <input type="number" id="cn-min" min="1" placeholder="Min">
      <span>&ndash;</span>
      <input type="number" id="cn-max" min="1" placeholder="Max">
    </div>

    <h3>Mana Value</h3>
    <div class="range-row">
      <input type="number" id="cmc-min" min="0" placeholder="Min">
      <span>&ndash;</span>
      <input type="number" id="cmc-max" min="0" placeholder="Max">
    </div>

    <h3>Finish</h3>
    <div class="pill-group" id="finish-filters">
      <input type="checkbox" id="ff-nonfoil" value="nonfoil"><label for="ff-nonfoil">Nonfoil</label>
      <input type="checkbox" id="ff-foil" value="foil"><label for="ff-foil">Foil</label>
      <input type="checkbox" id="ff-etched" value="etched"><label for="ff-etched">Etched</label>
    </div>

    <h3>Status</h3>
    <div class="pill-group" id="status-filters">
      <input type="checkbox" id="sf-ordered" value="ordered"><label for="sf-ordered">Ordered</label>
      <input type="checkbox" id="sf-wanted" value="wanted"><label for="sf-wanted">Wanted</label>
    </div>

    <h3>Treatment</h3>
    <div class="pill-group" id="badge-filters">
      <input type="checkbox" id="bf-borderless" value="borderless"><label for="bf-borderless">BL</label>
      <input type="checkbox" id="bf-showcase" value="showcase"><label for="bf-showcase">SC</label>
      <input type="checkbox" id="bf-extendedart" value="extendedart"><label for="bf-extendedart">EA</label>
      <input type="checkbox" id="bf-fullart" value="fullart"><label for="bf-fullart">FA</label>
      <input type="checkbox" id="bf-promo" value="promo"><label for="bf-promo">Promo</label>
    </div>

    <h3>Price (USD)</h3>
    <div class="range-row">
      <input type="number" id="price-min" min="0" step="0.01" placeholder="Min">
      <span>&ndash;</span>
      <input type="number" id="price-max" min="0" step="0.01" placeholder="Max">
    </div>

    <h3>Date Added</h3>
    <div class="range-row">
      <input type="date" id="date-min">
      <span>&ndash;</span>
      <input type="date" id="date-max">
    </div>

    <button style="margin-top:16px;width:100%" id="clear-filters-btn">Clear Filters</button>
  </aside>

  <div class="main" id="main">
    <div class="empty-state">Loading collection...</div>
  </div>
</div>

<div id="card-modal-overlay">
  <div class="card-modal" id="card-modal">
    <button class="modal-close" id="modal-close">&times;</button>
    <div class="card-modal-img">
      <div class="card-flip-container" id="modal-flip">
        <div class="card-flip-front"><img id="modal-img-front" src="" alt=""></div>
        <div class="card-flip-back"><img id="modal-img-back" src="" alt=""></div>
      </div>
      <button class="flip-btn" id="modal-flip-btn" title="Flip card">&#x21BB;</button>
    </div>
    <div class="card-modal-details" id="modal-details"></div>
  </div>
</div>

<div class="wishlist-backdrop" id="wishlist-backdrop"></div>
<div class="wishlist-panel" id="wishlist-panel">
  <div class="wishlist-panel-header">
    <h3>Wishlist</h3>
    <button class="modal-close" id="wishlist-close">&times;</button>
  </div>
  <div class="wishlist-panel-list" id="wishlist-panel-list"></div>
  <div class="wishlist-panel-footer">
    <div class="wl-cart-row">
      <button class="secondary" id="wl-copy-ck">Copy for CK</button>
      <button class="secondary" id="wl-copy-tcg">Copy for TCG</button>
    </div>
    <button class="secondary" id="wl-clear-all" style="background:#4a1a1a;border-color:#8b3a3a;color:#e8a0a0">Clear All</button>
  </div>
</div>

<script>
const searchInput = document.getElementById('search-input');
const viewTableBtn = document.getElementById('view-table-btn');
const viewGridBtn = document.getElementById('view-grid-btn');
const sidebarToggleBtn = document.getElementById('sidebar-toggle-btn');
const sidebar = document.getElementById('sidebar');
const main = document.getElementById('main');
const statusEl = document.getElementById('status');
const modalOverlay = document.getElementById('card-modal-overlay');
const modalImgFront = document.getElementById('modal-img-front');
const modalImgBack = document.getElementById('modal-img-back');
const modalFlip = document.getElementById('modal-flip');
const modalFlipBtn = document.getElementById('modal-flip-btn');
const modalDetails = document.getElementById('modal-details');
const modalClose = document.getElementById('modal-close');
const clearFiltersBtn = document.getElementById('clear-filters-btn');
const colConfigBtn = document.getElementById('col-config-btn');
const colConfigDropdown = document.getElementById('col-config-dropdown');
const moreMenuBtn = document.getElementById('more-menu-btn');
const moreMenuDropdown = document.getElementById('more-menu-dropdown');
const selectionBar = document.getElementById('selection-bar');
const selCountEl = document.getElementById('sel-count');
const selShareBtn = document.getElementById('sel-share-btn');

// Range inputs
const cnMinEl = document.getElementById('cn-min');
const cnMaxEl = document.getElementById('cn-max');
const cmcMinEl = document.getElementById('cmc-min');
const cmcMaxEl = document.getElementById('cmc-max');
const priceMinEl = document.getElementById('price-min');
const priceMaxEl = document.getElementById('price-max');
const dateMinEl = document.getElementById('date-min');
const dateMaxEl = document.getElementById('date-max');

const gridSizeWrap = document.getElementById('grid-size-wrap');
const gridSizeSlider = document.getElementById('grid-size-slider');

const includeUnownedBtn = document.getElementById('include-unowned-btn');
let includeUnowned = '';  // '' | 'base' | 'full'

let currentView = 'table';
let sortOrder = 'asc';
let sortColumn = 'name';
let allCards = [];
let allCardsUnfiltered = [];  // pre-status-filter snapshot for client-side re-filtering
let debounceTimer = null;
let _settings = {};
let multiSelectMode = false;
let selectedCards = new Set();
let lastSelectedIdx = null;
let wishlistMap = {};  // wishlist_id → {id, oracle_id, scryfall_id, name, set_code, collector_number, ...}
let wishlistByScryfall = {};  // scryfall_id → entry (only for printing-specific wants)
let wishlistByOracle = {};  // oracle_id → entry (only for card-level wants where scryfall_id is null)

function _addWishlistEntry(e) {
  wishlistMap[e.id] = e;
  if (e.scryfall_id) wishlistByScryfall[e.scryfall_id] = e;
  else wishlistByOracle[e.oracle_id] = e;
}
function _removeWishlistEntry(e) {
  delete wishlistMap[e.id];
  if (e.scryfall_id) delete wishlistByScryfall[e.scryfall_id];
  else delete wishlistByOracle[e.oracle_id];
}

// If entry has scryfall_id, only that printing is wanted; otherwise all printings of the oracle_id
function isCardWanted(card) {
  if (wishlistByScryfall[card.scryfall_id]) return true;
  return !!wishlistByOracle[card.oracle_id];
}
function getWishlistEntry(card) {
  return wishlistByScryfall[card.scryfall_id] || wishlistByOracle[card.oracle_id] || null;
}

// Grid size slider
const savedGridSize = localStorage.getItem('collectionGridCardSize');
if (savedGridSize) {
  gridSizeSlider.value = savedGridSize;
  document.documentElement.style.setProperty('--grid-card-width', savedGridSize + 'px');
}

gridSizeSlider.addEventListener('input', () => {
  const w = gridSizeSlider.value;
  document.documentElement.style.setProperty('--grid-card-width', w + 'px');
  localStorage.setItem('collectionGridCardSize', w);
});

const KEYRUNE_FALLBACKS = {
  tsb: 'tsp',
  pspm: 'spm',
  cst: 'csp',   // Coldsnap Theme Decks → Coldsnap
};
function keyruneSetCode(code) {
  const lc = (code || '').toLowerCase();
  return KEYRUNE_FALLBACKS[lc] || lc;
}

// Multi-select state
let selectedSets = new Map();   // code -> name
let selectedSubtypes = new Set();
let allSetOptions = [];         // [{code, name}]
let allSubtypeOptions = [];     // [string]
let cachedSets = [];            // [{code, name}] from /api/cached-sets

// --- Column definitions ---
const ALL_COLUMNS = [
  { key: 'qty', label: 'Qty', sort: 'qty', defaultOn: true },
  { key: 'name', label: 'Card', sort: 'name', defaultOn: true },
  { key: 'type', label: 'Type', sort: 'name', defaultOn: true },
  { key: 'mana', label: 'Cost', sort: 'cmc', defaultOn: true },
  { key: 'set', label: 'Set', sort: 'set', defaultOn: true },
  { key: 'collector_number', label: '#', sort: 'collector_number', defaultOn: true },
  { key: 'price', label: 'Price', sort: 'price', defaultOn: true },
  { key: 'condition', label: 'Cond.', sort: 'name', defaultOn: false },
  { key: 'date_added', label: 'Added', sort: 'date_added', defaultOn: false },
  { key: 'ck_price', label: 'CK $', sort: 'ck_price', defaultOn: false },
  { key: 'tcg_price', label: 'TCG $', sort: 'tcg_price', defaultOn: false },
];

const DEFAULT_COLS = ALL_COLUMNS.filter(c => c.defaultOn).map(c => c.key);
let enabledCols = JSON.parse(localStorage.getItem('collectionCols') || 'null') || DEFAULT_COLS;

function getVisibleColumns() {
  return ALL_COLUMNS.filter(c => enabledCols.includes(c.key));
}

function saveColumns() {
  localStorage.setItem('collectionCols', JSON.stringify(enabledCols));
}

const COL_SORT_MAP = Object.fromEntries(ALL_COLUMNS.map(c => [c.key, c.sort]));

// --- Column config dropdown ---
function renderColConfig() {
  colConfigDropdown.innerHTML = '';
  for (const col of ALL_COLUMNS) {
    const label = document.createElement('label');
    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.checked = enabledCols.includes(col.key);
    cb.addEventListener('change', () => {
      if (cb.checked) {
        if (!enabledCols.includes(col.key)) enabledCols.push(col.key);
      } else {
        enabledCols = enabledCols.filter(k => k !== col.key);
      }
      saveColumns();
      render();
    });
    label.appendChild(cb);
    label.appendChild(document.createTextNode(col.label));
    colConfigDropdown.appendChild(label);
  }
}
renderColConfig();

colConfigBtn.addEventListener('click', (e) => {
  e.stopPropagation();
  colConfigDropdown.classList.toggle('open');
  moreMenuDropdown.classList.remove('open');
});
moreMenuBtn.addEventListener('click', (e) => {
  e.stopPropagation();
  moreMenuDropdown.classList.toggle('open');
  colConfigDropdown.classList.remove('open');
});
document.addEventListener('click', (e) => {
  if (!colConfigDropdown.contains(e.target) && e.target !== colConfigBtn) {
    colConfigDropdown.classList.remove('open');
  }
  if (!moreMenuDropdown.contains(e.target) && e.target !== moreMenuBtn) {
    moreMenuDropdown.classList.remove('open');
  }
});

// --- Multi-select ---
const selShareResult = document.getElementById('sel-share-result');

document.getElementById('toggle-multiselect-btn').addEventListener('click', () => {
  moreMenuDropdown.classList.remove('open');
  multiSelectMode = !multiSelectMode;
  selectedCards.clear();
  lastSelectedIdx = null;
  updateSelectionBar();
  render();
});

document.getElementById('sel-all').addEventListener('click', () => {
  for (let i = 0; i < allCards.length; i++) selectedCards.add(i);
  updateSelectionBar();
  render();
});

document.getElementById('sel-none').addEventListener('click', () => {
  selectedCards.clear();
  lastSelectedIdx = null;
  updateSelectionBar();
  render();
});

selShareBtn.addEventListener('click', async () => {
  if (selectedCards.size === 0) return;
  const terms = Array.from(selectedCards).map(i => {
    const c = allCards[i];
    return `(s:${c.set_code.toLowerCase()} cn:${c.collector_number})`;
  });
  const q = terms.join(' or ');
  const sfUrl = `https://scryfall.com/search?unique=prints&q=${encodeURIComponent(q)}`;
  if (sfUrl.length > 8000) {
    alert(`URL is ${sfUrl.length} characters (limit ~8000). Select fewer cards.`);
    return;
  }
  selShareBtn.disabled = true;
  selShareBtn.textContent = 'Shortening...';
  try {
    const res = await fetch(`/api/shorten?url=${encodeURIComponent(sfUrl)}`);
    if (!res.ok) throw new Error();
    const data = await res.json();
    const shortUrl = data.short_url;
    selShareResult.innerHTML = `<a class="sel-share-link" href="${shortUrl}" target="_blank" rel="noopener">Open in Scryfall</a>`;
  } catch {
    selShareResult.innerHTML = `<a class="sel-share-link" href="${sfUrl}" target="_blank" rel="noopener">Open on Scryfall</a>`;
  }
  selShareBtn.disabled = false;
  selShareBtn.textContent = 'Share';
});

document.getElementById('sel-want-btn').addEventListener('click', async () => {
  if (selectedCards.size === 0) return;
  const toAdd = [];
  for (const i of selectedCards) {
    const c = allCards[i];
    if (!isCardWanted(c)) {
      toAdd.push({ name: c.name.split(' // ')[0], set_code: c.set_code, collector_number: c.collector_number });
    }
  }
  if (toAdd.length === 0) {
    selShareResult.textContent = 'All selected cards already on wishlist';
    return;
  }
  const btn = document.getElementById('sel-want-btn');
  btn.disabled = true;
  btn.textContent = `Adding ${toAdd.length}...`;
  const res = await fetch('/api/wishlist/bulk', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ cards: toAdd }),
  });
  const result = await res.json();
  for (const entry of result.added) {
    _addWishlistEntry(entry);
  }
  updateWishlistCount();
  renderWishlistPanel();
  const errCount = result.errors.length;
  selShareResult.textContent = `${result.added.length} added to wishlist` + (errCount ? `, ${errCount} failed` : '');
  btn.disabled = false;
  btn.textContent = 'Want';
});

function updateSelectionBar() {
  selectionBar.classList.toggle('active', multiSelectMode);
  selCountEl.textContent = `${selectedCards.size} selected`;
  selShareResult.innerHTML = '';
}

function toggleCardSelection(idx, shiftKey) {
  if (shiftKey && lastSelectedIdx != null) {
    const lo = Math.min(lastSelectedIdx, idx);
    const hi = Math.max(lastSelectedIdx, idx);
    for (let i = lo; i <= hi; i++) selectedCards.add(i);
  } else {
    if (selectedCards.has(idx)) selectedCards.delete(idx);
    else selectedCards.add(idx);
  }
  lastSelectedIdx = idx;
  updateSelectionBar();
}

function handleSortClick(colKey) {
  if (sortColumn === colKey) {
    sortOrder = sortOrder === 'asc' ? 'desc' : 'asc';
  } else {
    sortColumn = colKey;
    sortOrder = 'asc';
  }
  refilterAndRender();
}

// --- Rarity/set border colors ---
const RARITY_COLORS = {common: '#111', uncommon: '#6a6a6a', rare: '#c9a816', mythic: '#d4422a'};
function getRarityColor(rarity) { return RARITY_COLORS[rarity] || '#111'; }

// --- Card detail modal ---
modalOverlay.addEventListener('click', (e) => {
  if (e.target === modalOverlay) modalOverlay.classList.remove('active');
});
modalClose.addEventListener('click', () => modalOverlay.classList.remove('active'));
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') modalOverlay.classList.remove('active');
});

// Modal filter click handler (delegated, added once)
modalDetails.addEventListener('click', (e) => {
  if (e.target.closest('a')) return;
  const filterEl = e.target.closest('[data-filter-type]');
  if (filterEl) {
    e.stopPropagation();
    modalOverlay.classList.remove('active');
    applyFilter(filterEl.dataset.filterType, filterEl.dataset.filterValue);
  }
});

const DFC_LAYOUTS = ['transform', 'modal_dfc', 'reversible_card', 'double_faced_token', 'art_series'];

function showCardModal(card) {
  // Front image
  modalImgFront.src = card.image_uri || '';
  modalImgFront.alt = card.name;

  // Back image
  const isDfc = DFC_LAYOUTS.includes(card.layout);
  const backSrc = isDfc ? (card.image_uri || '').replace('/front/', '/back/') : '/static/card_back.jpeg';
  modalImgBack.src = backSrc;
  modalImgBack.alt = isDfc ? 'Back face' : 'Card back';

  // Reset flip state
  modalFlip.classList.remove('flipped');

  // Build modal details data for both faces
  const modalState = { card, isDfc, showingBack: false };

  const CONDITION_LABELS = {
    'Near Mint': 'Near Mint', 'Lightly Played': 'Lightly Played',
    'Moderately Played': 'Moderately Played', 'Heavily Played': 'Heavily Played',
    'Damaged': 'Damaged',
  };
  const condition = CONDITION_LABELS[card.condition] || card.condition || 'Near Mint';
  const finish = card.finish ? card.finish.charAt(0).toUpperCase() + card.finish.slice(1) : 'Nonfoil';

  // Prices
  const tcgPrice = card.tcg_price ? `$${parseFloat(card.tcg_price).toFixed(2)}` : '—';
  const ckPrice = card.ck_price ? `$${parseFloat(card.ck_price).toFixed(2)}` : '—';

  // Links
  const sfUrl = `https://scryfall.com/card/${card.set_code.toLowerCase()}/${card.collector_number}`;
  const ckUrl = getCkUrl(card);

  // Tags
  const fe = parseJsonField(card.frame_effects);
  let tagsHtml = '';
  if (card.finish === 'foil') tagsHtml += '<span class="foil-tag filterable" data-filter-type="finish" data-filter-value="foil">Foil</span>';
  if (card.finish === 'etched') tagsHtml += '<span class="foil-tag filterable" data-filter-type="finish" data-filter-value="etched">Etched</span>';
  if (card.border_color === 'borderless') tagsHtml += '<span class="treat-tag filterable" data-filter-type="badge" data-filter-value="borderless">Borderless</span>';
  if (fe.includes('showcase')) tagsHtml += '<span class="treat-tag filterable" data-filter-type="badge" data-filter-value="showcase">Showcase</span>';
  if (fe.includes('extendedart')) tagsHtml += '<span class="treat-tag filterable" data-filter-type="badge" data-filter-value="extendedart">Extended Art</span>';
  if (card.full_art) tagsHtml += '<span class="treat-tag filterable" data-filter-type="badge" data-filter-value="fullart">Full Art</span>';
  if (fe.includes('inverted')) tagsHtml += '<span class="treat-tag">Inverted</span>';
  if (card.promo) tagsHtml += '<span class="promo-tag filterable" data-filter-type="badge" data-filter-value="promo">Promo</span>';

  // Set info
  const setCode = card.set_code.toLowerCase();
  const rarityClass = `ss-${card.rarity || 'common'}`;
  const setIcon = `<i class="ss ss-${setCode} ${rarityClass} ss-grad"></i>`;
  const setName = card.set_name || card.set_code.toUpperCase();
  const rarity = card.rarity ? card.rarity.charAt(0).toUpperCase() + card.rarity.slice(1) : '';

  // DFC face splitting
  const names = card.name.split(' // ');
  const types = (card.type_line || '').split(' // ');
  const manas = (card.mana_cost || '').split(' // ');
  const isArtSeries = card.layout === 'art_series';

  function renderDetails(faceIdx) {
    let faceName, faceType, faceMana;
    if (isDfc && names.length > 1) {
      faceName = names[faceIdx] || names[0];
      faceType = isArtSeries ? 'Art Series' : (types[faceIdx] || types[0] || '');
      faceMana = manas[faceIdx] || manas[0] || '';
    } else {
      faceName = isArtSeries ? names[0] : card.name;
      faceType = isArtSeries ? 'Art Series' : (card.type_line || '');
      faceMana = card.mana_cost || '';
    }
    const manaHtml = faceMana ? renderMana(faceMana) : '';
    const cmcText = card.cmc != null ? card.cmc : '';

    const faceMainType = faceType.split(' \u2014 ')[0] || '';
    const facePrimary = getPrimaryType(faceMainType);
    const typeValueHtml = facePrimary
      ? `<span class="filterable" data-filter-type="type" data-filter-value="${facePrimary}">${faceType}</span>`
      : faceType;

    modalDetails.innerHTML = `
      <h2 class="filterable" data-filter-type="name" data-filter-value="${faceName.replace(/"/g, '&quot;')}">${faceName}</h2>
      ${card.oracle_name ? `<div style="font-size:0.85rem;color:#888;margin-top:2px">${card.oracle_name}</div>` : ''}
      ${manaHtml ? `<div class="modal-mana">${manaHtml}</div>` : ''}
      <div class="modal-section">
        <span class="modal-section-title">Type</span>
        <span class="value">${typeValueHtml}</span>
        ${cmcText !== '' ? `<div class="modal-row"><span class="label">Mana Value</span><span class="value">${cmcText}</span></div>` : ''}
      </div>
      <div class="modal-section">
        <span class="modal-section-title">Printing</span>
        <div class="modal-row"><span class="label">Set</span><span class="value filterable" data-filter-type="set" data-filter-value="${card.set_code}">${setIcon} ${setName} (${card.set_code.toUpperCase()})</span></div>
        <div class="modal-row"><span class="label">Number</span><span class="value">${card.collector_number || ''}</span></div>
        <div class="modal-row"><span class="label">Rarity</span><span class="value filterable" data-filter-type="rarity" data-filter-value="${card.rarity || 'common'}">${rarity}</span></div>
      </div>
      <div class="modal-section">
        <span class="modal-section-title">Collection</span>
        <div class="modal-row"><span class="label">Quantity</span><span class="value">${card.qty}</span></div>
        <div class="modal-row"><span class="label">Condition</span><span class="value">${condition}</span></div>
        <div class="modal-row"><span class="label">Finish</span><span class="value filterable" data-filter-type="finish" data-filter-value="${card.finish || 'nonfoil'}">${finish}</span></div>
      </div>
      ${tagsHtml ? `<div class="modal-section"><span class="modal-section-title">Treatments</span><div class="modal-tags">${tagsHtml}</div></div>` : ''}
      ${card.order_id ? `<div class="modal-section"><span class="modal-section-title">Order</span>
        <div class="modal-row"><span class="label">Seller</span><span class="value">${card.order_seller || ''}</span></div>
        <div class="modal-row"><span class="label">Order #</span><span class="value">${card.order_number || ''}</span></div>
        ${card.order_date ? `<div class="modal-row"><span class="label">Date</span><span class="value">${card.order_date}</span></div>` : ''}
        ${card.purchase_price ? `<div class="modal-row"><span class="label">Price</span><span class="value">$${parseFloat(card.purchase_price).toFixed(2)}</span></div>` : ''}
      </div>` : ''}
      ${(() => {
        const wl = getWishlistEntry(card);
        if (!wl) return '';
        const addedDate = wl.added_at ? new Date(wl.added_at).toLocaleDateString() : '';
        return `<div class="modal-section"><span class="modal-section-title" style="color:#7ee8b0">Wishlist</span>
          ${addedDate ? `<div class="modal-row"><span class="label">Added</span><span class="value">${addedDate}</span></div>` : ''}
          ${wl.max_price ? `<div class="modal-row"><span class="label">Max Price</span><span class="value">$${parseFloat(wl.max_price).toFixed(2)}</span></div>` : ''}
          ${wl.priority ? `<div class="modal-row"><span class="label">Priority</span><span class="value">${wl.priority}</span></div>` : ''}
          ${wl.notes ? `<div class="modal-row"><span class="label">Notes</span><span class="value">${wl.notes}</span></div>` : ''}
          ${wl.source ? `<div class="modal-row"><span class="label">Source</span><span class="value">${wl.source}</span></div>` : ''}
        </div>`;
      })()}
      <div class="modal-links">
        <a class="badge link" href="${sfUrl}" target="_blank" rel="noopener">SF${tcgPrice !== '—' ? ' ' + tcgPrice : ''}</a>
        <a class="badge link" href="${ckUrl}" target="_blank" rel="noopener">CK${ckPrice !== '—' ? ' ' + ckPrice : ''}</a>
        <button class="want-btn${getWishlistEntry(card) ? ' wanted' : ''}" id="modal-want-btn">${getWishlistEntry(card) ? 'Wanted' : 'Want'}</button>
      </div>
      ${card.ingest_lineage ? `<div class="modal-section"><span class="modal-section-title">Lineage</span>
        ${card.ingest_lineage.map(l => `<div class="modal-row"><span class="label">${new Date(l.created_at).toLocaleDateString()}</span><span class="value"><a href="/correct?image_id=${l.image_id}&card_idx=${l.card_idx}">View image</a></span></div>`).join('')}
      </div>` : ''}
    `;
  }

  renderDetails(0);

  // Want button handler
  modalDetails.addEventListener('click', async (e) => {
    const btn = e.target.closest('#modal-want-btn');
    if (!btn) return;
    e.stopPropagation();
    const existing = getWishlistEntry(card);
    if (existing) {
      // Remove from wishlist
      await fetch(`/api/wishlist/${existing.id}`, { method: 'DELETE' });
      _removeWishlistEntry(existing);
      btn.classList.remove('wanted');
      btn.textContent = 'Want';
    } else {
      // Add to wishlist (printing-specific since we have set_code)
      const body = { name: card.name.split(' // ')[0] };
      if (card.set_code) body.set_code = card.set_code;
      if (card.collector_number) body.collector_number = card.collector_number;
      const res = await fetch('/api/wishlist', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      });
      const result = await res.json();
      if (result.id) {
        const entry = {
          id: result.id, oracle_id: card.oracle_id, scryfall_id: result.scryfall_id,
          name: card.name, set_code: card.set_code, collector_number: card.collector_number,
        };
        _addWishlistEntry(entry);
        btn.classList.add('wanted');
        btn.textContent = 'Wanted';
      }
    }
    updateWishlistCount();
    renderWishlistPanel();
  });

  // Flip button handler
  modalFlipBtn.onclick = () => {
    modalState.showingBack = !modalState.showingBack;
    modalFlip.classList.toggle('flipped');
    if (isDfc) renderDetails(modalState.showingBack ? 1 : 0);
  };

  modalOverlay.classList.add('active');
}

// --- CK URL helper ---
function getCkUrl(card) {
  if (card.ck_url) return card.ck_url;
  const ckSearch = encodeURIComponent(card.name.split(' // ')[0]);
  return `https://www.cardkingdom.com/catalog/search?search=header&filter%5Bname%5D=${ckSearch}`;
}

// --- Price badges (for table price column) ---
function buildPriceBadges(card) {
  let html = '';
  const sources = (_settings.price_sources || 'tcg,ck').split(',');
  if (sources.includes('tcg')) {
    const sfPrice = card.tcg_price ? ` $${parseFloat(card.tcg_price).toFixed(2)}` : '';
    html += `<a class="badge link" href="https://scryfall.com/card/${card.set_code.toLowerCase()}/${card.collector_number}" target="_blank" rel="noopener" onclick="event.stopPropagation()">SF${sfPrice}</a>`;
  }
  if (sources.includes('ck')) {
    const ckPrice = card.ck_price ? ` $${parseFloat(card.ck_price).toFixed(2)}` : '';
    html += `<a class="badge link" href="${getCkUrl(card)}" target="_blank" rel="noopener" onclick="event.stopPropagation()">CK${ckPrice}</a>`;
  }
  return html;
}

// --- Badge builder (for grid view) ---
function buildCardBadges(card) {
  let html = '';
  const sources = (_settings.price_sources || 'tcg,ck').split(',');
  if (sources.includes('tcg') && card.scryfall_id) {
    const sfPrice = card.tcg_price ? ` $${parseFloat(card.tcg_price).toFixed(2)}` : '';
    html += `<a class="badge link" href="https://scryfall.com/card/${card.set_code.toLowerCase()}/${card.collector_number}" target="_blank" rel="noopener" onclick="event.stopPropagation()">SF${sfPrice}</a>`;
  }
  if (sources.includes('ck')) {
    const ckPrice = card.ck_price ? ` $${parseFloat(card.ck_price).toFixed(2)}` : '';
    html += `<a class="badge link" href="${getCkUrl(card)}" target="_blank" rel="noopener" onclick="event.stopPropagation()">CK${ckPrice}</a>`;
  }
  const fe = parseJsonField(card.frame_effects);
  if (card.border_color === 'borderless') html += '<span class="badge treatment filterable" data-filter-type="badge" data-filter-value="borderless">BL</span>';
  if (fe.includes('showcase')) html += '<span class="badge treatment filterable" data-filter-type="badge" data-filter-value="showcase">SC</span>';
  if (fe.includes('extendedart')) html += '<span class="badge treatment filterable" data-filter-type="badge" data-filter-value="extendedart">EA</span>';
  if (card.full_art) html += '<span class="badge treatment filterable" data-filter-type="badge" data-filter-value="fullart">FA</span>';
  if (card.finish === 'foil') html += '<span class="foil-tag filterable" data-filter-type="finish" data-filter-value="foil">Foil</span>';
  if (card.finish === 'etched') html += '<span class="foil-tag filterable" data-filter-type="finish" data-filter-value="etched">Etched</span>';
  return html;
}

function parseJsonField(val) {
  if (!val) return [];
  if (Array.isArray(val)) return val;
  try { return JSON.parse(val); } catch { return []; }
}

function renderMana(cost) {
  if (!cost) return '';
  return cost.replace(/\{([^}]+)\}/g, (_, sym) => {
    const cls = sym.toLowerCase().replace(/\//g, '');
    return `<i class="ms ms-${cls} ms-cost ms-shadow"></i>`;
  });
}

function buildInlineTags(card) {
  let html = '';
  if (card.finish === 'foil') html += '<span class="card-tag foil-tag" title="Foil">F</span>';
  else if (card.finish === 'etched') html += '<span class="card-tag foil-tag" title="Etched foil">E</span>';
  const fe = parseJsonField(card.frame_effects);
  const isBorderless = card.border_color === 'borderless';
  if (isBorderless) html += '<span class="card-tag treat-tag" title="Borderless">BL</span>';
  if (fe.includes('showcase')) html += '<span class="card-tag treat-tag" title="Showcase frame">SC</span>';
  if (fe.includes('extendedart')) html += '<span class="card-tag treat-tag" title="Extended art">EA</span>';
  if (card.full_art && !isBorderless) html += '<span class="card-tag treat-tag" title="Full art">FA</span>';
  if (fe.includes('inverted')) html += '<span class="card-tag treat-tag" title="Inverted frame">IN</span>';
  if (card.promo) html += '<span class="card-tag promo-tag" title="Promo">P</span>';
  if (!card.owned && isCardWanted(card)) html += '<span class="card-tag wanted-tag" title="Wanted">W</span>';
  if (card.status === 'ordered') html += '<span class="card-tag ordered-tag" title="Ordered">ORD</span>';
  return html;
}

// --- Multi-select component ---
function initMultiSelect(config) {
  const searchEl = document.getElementById(config.searchId);
  const dropdownEl = document.getElementById(config.dropdownId);
  const pillsEl = document.getElementById(config.pillsId);

  function renderDropdown(filter) {
    const q = (filter || '').toLowerCase();
    const items = config.getOptions().filter(item => {
      const label = config.getLabel(item).toLowerCase();
      return !q || label.includes(q);
    });
    dropdownEl.innerHTML = '';
    for (const item of items.slice(0, 50)) {
      const li = document.createElement('li');
      const key = config.getKey(item);
      li.textContent = config.getLabel(item);
      if (config.isSelected(key)) li.classList.add('selected');
      li.addEventListener('mousedown', (e) => {
        e.preventDefault();
        config.toggle(key, item);
        renderPills();
        renderDropdown(searchEl.value);
        (config.onChange || refilterAndRender)();
      });
      dropdownEl.appendChild(li);
    }
  }

  function renderPills() {
    pillsEl.innerHTML = '';
    for (const [key, label] of config.getSelected()) {
      const pill = document.createElement('span');
      pill.className = 'selected-pill';
      pill.innerHTML = `${label} <span class="remove-pill">&times;</span>`;
      pill.querySelector('.remove-pill').addEventListener('click', () => {
        config.remove(key);
        renderPills();
        renderDropdown(searchEl.value);
        (config.onChange || refilterAndRender)();
      });
      pillsEl.appendChild(pill);
    }
  }

  searchEl.addEventListener('focus', () => {
    renderDropdown(searchEl.value);
    dropdownEl.classList.add('open');
  });
  searchEl.addEventListener('input', () => {
    renderDropdown(searchEl.value);
    dropdownEl.classList.add('open');
  });
  searchEl.addEventListener('blur', () => {
    setTimeout(() => dropdownEl.classList.remove('open'), 150);
  });

  return { renderPills, renderDropdown };
}

// Set multi-select
const setMultiSelect = initMultiSelect({
  searchId: 'set-search',
  dropdownId: 'set-dropdown',
  pillsId: 'set-pills',
  getOptions: () => allSetOptions,
  getLabel: (item) => `${item.name} (${item.code.toUpperCase()})`,
  getKey: (item) => item.code,
  isSelected: (key) => selectedSets.has(key),
  toggle: (key, item) => {
    if (selectedSets.has(key)) selectedSets.delete(key);
    else selectedSets.set(key, item.name);
  },
  remove: (key) => selectedSets.delete(key),
  getSelected: () => Array.from(selectedSets.entries()).map(([k, v]) => [k, `${v} (${k.toUpperCase()})`]),
  onChange: () => includeUnowned ? fetchCollection() : refilterAndRender(),
});

// Subtype multi-select
const subtypeMultiSelect = initMultiSelect({
  searchId: 'subtype-search',
  dropdownId: 'subtype-dropdown',
  pillsId: 'subtype-pills',
  getOptions: () => allSubtypeOptions,
  getLabel: (item) => item,
  getKey: (item) => item,
  isSelected: (key) => selectedSubtypes.has(key),
  toggle: (key) => {
    if (selectedSubtypes.has(key)) selectedSubtypes.delete(key);
    else selectedSubtypes.add(key);
  },
  remove: (key) => selectedSubtypes.delete(key),
  getSelected: () => Array.from(selectedSubtypes).map(s => [s, s]),
});

// --- Filterable click helpers ---
const TYPE_KEYWORDS = ['Creature','Instant','Sorcery','Enchantment','Artifact','Planeswalker','Land','Battle','Kindred','Token'];
function getPrimaryType(mainType) {
  const words = mainType.split(/\s+/);
  for (let i = words.length - 1; i >= 0; i--) {
    if (TYPE_KEYWORDS.includes(words[i])) return words[i];
  }
  return null;
}

function applyFilter(type, value) {
  switch (type) {
    case 'name':
      searchInput.value = value;
      break;
    case 'set': {
      const opt = allSetOptions.find(s => s.code === value);
      if (opt && !selectedSets.has(value)) {
        selectedSets.set(value, opt.name);
        setMultiSelect.renderPills();
      }
      break;
    }
    case 'rarity': {
      const cb = document.getElementById(`rf-${value}`);
      if (cb) cb.checked = true;
      break;
    }
    case 'type': {
      const cb = document.getElementById(`tf-${value.toLowerCase()}`);
      if (cb) cb.checked = true;
      break;
    }
    case 'subtype':
      if (!selectedSubtypes.has(value)) {
        selectedSubtypes.add(value);
        subtypeMultiSelect.renderPills();
      }
      break;
    case 'cmc':
      cmcMinEl.value = value;
      cmcMaxEl.value = value;
      break;
    case 'finish': {
      const cb = document.getElementById(`ff-${value}`);
      if (cb) cb.checked = true;
      break;
    }
    case 'badge': {
      const cb = document.getElementById(`bf-${value}`);
      if (cb) cb.checked = true;
      break;
    }
    case 'date_added':
      dateMinEl.value = value;
      dateMaxEl.value = value;
      break;
  }
  // Name search changes the query — needs a fetch. All others are client-side.
  if (type === 'name') fetchCollection();
  else refilterAndRender();
}

// --- View toggle ---
viewTableBtn.addEventListener('click', () => { currentView = 'table'; updateViewButtons(); render(); });
viewGridBtn.addEventListener('click', () => { currentView = 'grid'; updateViewButtons(); render(); });

function updateViewButtons() {
  viewTableBtn.classList.toggle('active', currentView === 'table');
  viewGridBtn.classList.toggle('active', currentView === 'grid');
  gridSizeWrap.style.display = currentView === 'grid' ? '' : 'none';
  document.querySelector('.col-config-wrap').style.display = currentView === 'table' ? '' : 'none';
}
updateViewButtons();

// --- Sidebar toggle (slide-in panel) ---
const sidebarBackdrop = document.getElementById('sidebar-backdrop');
function toggleSidebar(open) {
  if (open === undefined) open = !sidebar.classList.contains('open');
  sidebar.classList.toggle('open', open);
  sidebarBackdrop.classList.toggle('active', open);
  sidebarToggleBtn.classList.toggle('active', open);
}
sidebarToggleBtn.addEventListener('click', () => toggleSidebar());
sidebarBackdrop.addEventListener('click', () => toggleSidebar(false));

// --- Include Unowned toggle (cycles: '' -> 'base' -> 'full' -> '') ---
const UNOWNED_CYCLE = ['', 'base', 'full'];
const UNOWNED_LABELS = { '': '+ Unowned', 'base': '+ Unowned', 'full': '+ Full Set' };

includeUnownedBtn.addEventListener('click', () => {
  if (!hasAnyFilter()) return;
  const idx = UNOWNED_CYCLE.indexOf(includeUnowned);
  includeUnowned = UNOWNED_CYCLE[(idx + 1) % UNOWNED_CYCLE.length];
  updateUnownedBtn();
  fetchCollection();
});

function updateUnownedBtn() {
  const canEnable = hasAnyFilter();
  includeUnownedBtn.disabled = !canEnable;
  if (!canEnable && includeUnowned) {
    includeUnowned = '';
  }
  includeUnownedBtn.classList.toggle('active', !!includeUnowned);
  includeUnownedBtn.textContent = UNOWNED_LABELS[includeUnowned] || '+ Unowned';
  document.getElementById('buy-missing-wrap').classList.toggle('visible', !!includeUnowned);
}

// --- Fetch ---
function getFetchParams() {
  const params = new URLSearchParams();
  const q = searchInput.value.trim();
  if (q) params.set('q', q);
  if (includeUnowned && hasAnyFilter()) {
    params.set('include_unowned', includeUnowned);
    // Send selected sets for server-side caching (ensure_set_cached)
    for (const code of selectedSets.keys()) {
      params.append('filter_set', code);
    }
  }
  return params.toString();
}

function hasAnyFilter() {
  if (searchInput.value.trim()) return true;
  if (selectedSets.size) return true;
  if (document.querySelectorAll('#color-filters input:checked').length) return true;
  if (document.querySelectorAll('#rarity-filters input:checked').length) return true;
  if (document.querySelectorAll('#type-filters input:checked').length) return true;
  if (selectedSubtypes.size) return true;
  if (document.querySelectorAll('#finish-filters input:checked').length) return true;
  if (document.querySelectorAll('#badge-filters input:checked').length) return true;
  if (document.querySelectorAll('#status-filters input:checked').length) return true;
  if (cmcMinEl.value || cmcMaxEl.value) return true;
  if (dateMinEl.value || dateMaxEl.value) return true;
  return false;
}

function applyAllClientFilters(cards) {
  // Color
  const colors = Array.from(document.querySelectorAll('#color-filters input:checked')).map(cb => cb.value);
  if (colors.length) {
    cards = cards.filter(c => {
      let cardColors;
      try { cardColors = JSON.parse(c.colors || '[]'); } catch { cardColors = []; }
      return colors.every(col =>
        col === 'C' ? cardColors.length === 0 : cardColors.includes(col)
      );
    });
  }

  // Rarity
  const rarities = Array.from(document.querySelectorAll('#rarity-filters input:checked')).map(cb => cb.value);
  if (rarities.length) {
    cards = cards.filter(c => rarities.includes(c.rarity));
  }

  // Set
  if (selectedSets.size) {
    cards = cards.filter(c => selectedSets.has(c.set_code));
  }

  // Type
  const types = Array.from(document.querySelectorAll('#type-filters input:checked')).map(cb => cb.value);
  if (types.length) {
    cards = cards.filter(c => types.some(t => (c.type_line || '').includes(t)));
  }

  // Subtype
  if (selectedSubtypes.size) {
    cards = cards.filter(c => {
      const tl = c.type_line || '';
      return Array.from(selectedSubtypes).some(st => tl.includes(st));
    });
  }

  // Finish
  const finishes = Array.from(document.querySelectorAll('#finish-filters input:checked')).map(cb => cb.value);
  if (finishes.length) {
    cards = cards.filter(c => finishes.includes(c.finish));
  }

  // Badge / Treatment
  const badges = Array.from(document.querySelectorAll('#badge-filters input:checked')).map(cb => cb.value);
  if (badges.length) {
    cards = cards.filter(c => {
      let fe;
      try { fe = JSON.parse(c.frame_effects || '[]'); } catch { fe = []; }
      return badges.some(b => {
        if (b === 'borderless') return c.border_color === 'borderless';
        if (b === 'showcase') return fe.includes('showcase');
        if (b === 'extendedart') return fe.includes('extendedart');
        if (b === 'fullart') return c.full_art;
        if (b === 'promo') return c.promo;
        return false;
      });
    });
  }

  // CMC range
  const cmcMin = parseFloat(cmcMinEl.value);
  const cmcMax = parseFloat(cmcMaxEl.value);
  if (!isNaN(cmcMin) || !isNaN(cmcMax)) {
    cards = cards.filter(c => {
      const cmc = c.cmc || 0;
      if (!isNaN(cmcMin) && cmc < cmcMin) return false;
      if (!isNaN(cmcMax) && cmc > cmcMax) return false;
      return true;
    });
  }

  // Date range
  const dateMin = dateMinEl.value;
  const dateMax = dateMaxEl.value;
  if (dateMin || dateMax) {
    cards = cards.filter(c => {
      const d = c.acquired_at || '';
      if (dateMin && d < dateMin) return false;
      if (dateMax && d > dateMax + 'Z') return false;
      return true;
    });
  }

  // Collector number range
  const cnMin = parseInt(cnMinEl.value);
  const cnMax = parseInt(cnMaxEl.value);
  if (!isNaN(cnMin) || !isNaN(cnMax)) {
    cards = cards.filter(c => {
      const cn = parseInt(c.collector_number) || 0;
      if (!isNaN(cnMin) && cn < cnMin) return false;
      if (!isNaN(cnMax) && cn > cnMax) return false;
      return true;
    });
  }

  // Price range
  const pMin = parseFloat(priceMinEl.value);
  const pMax = parseFloat(priceMaxEl.value);
  if (!isNaN(pMin) || !isNaN(pMax)) {
    cards = cards.filter(c => {
      const price = parseFloat(c.tcg_price) || 0;
      if (!isNaN(pMin) && price < pMin) return false;
      if (!isNaN(pMax) && price > pMax) return false;
      return true;
    });
  }

  // Status: Ordered / Wanted
  const orderedOnly = document.getElementById('sf-ordered').checked;
  const wantedOnly = document.getElementById('sf-wanted').checked;
  if (orderedOnly || wantedOnly) {
    cards = cards.filter(c => {
      if (orderedOnly && c.status === 'ordered') return true;
      if (wantedOnly && isCardWanted(c)) return true;
      return false;
    });
  }

  return cards;
}

function applyClientSort(cards) {
  const sortKey = COL_SORT_MAP[sortColumn] || 'name';
  const dir = sortOrder === 'desc' ? -1 : 1;

  cards.sort((a, b) => {
    let va, vb;
    switch (sortKey) {
      case 'name': va = (a.name || '').toLowerCase(); vb = (b.name || '').toLowerCase(); break;
      case 'cmc': va = a.cmc || 0; vb = b.cmc || 0; break;
      case 'rarity': {
        const rm = {common:0, uncommon:1, rare:2, mythic:3};
        va = rm[a.rarity] ?? 4; vb = rm[b.rarity] ?? 4; break;
      }
      case 'set': va = a.set_code || ''; vb = b.set_code || ''; break;
      case 'color': va = a.color_identity || '[]'; vb = b.color_identity || '[]'; break;
      case 'qty': va = a.qty || 0; vb = b.qty || 0; break;
      case 'collector_number': va = parseInt(a.collector_number) || 0; vb = parseInt(b.collector_number) || 0; break;
      case 'date_added': va = a.acquired_at || ''; vb = b.acquired_at || ''; break;
      case 'price': {
        const pf = ((_settings.price_sources || 'tcg,ck').split(',')[0] === 'ck') ? 'ck_price' : 'tcg_price';
        va = parseFloat(a[pf]) || 0; vb = parseFloat(b[pf]) || 0; break;
      }
      default:
        // Price columns
        if (sortKey === 'tcg_price' || sortColumn === 'tcg_price') { va = parseFloat(a.tcg_price) || 0; vb = parseFloat(b.tcg_price) || 0; }
        else if (sortKey === 'ck_price' || sortColumn === 'ck_price') { va = parseFloat(a.ck_price) || 0; vb = parseFloat(b.ck_price) || 0; }
        else { va = (a.name || '').toLowerCase(); vb = (b.name || '').toLowerCase(); }
    }
    if (va < vb) return -1 * dir;
    if (va > vb) return 1 * dir;
    // Secondary sort by name
    const na = (a.name || '').toLowerCase(), nb = (b.name || '').toLowerCase();
    return na < nb ? -1 : na > nb ? 1 : 0;
  });
  return cards;
}

function refilterAndRender() {
  updateUnownedBtn();
  allCards = applyClientSort(applyAllClientFilters([...allCardsUnfiltered]));
  updateStatusText();
  render();
}

function updateStatusText() {
  const sources = (_settings.price_sources || 'tcg,ck').split(',');
  const priceField = sources[0] === 'ck' ? 'ck_price' : 'tcg_price';
  const priceLabel = sources[0] === 'ck' ? 'CK' : 'TCG';
  if (includeUnowned) {
    const ownedCards = allCards.filter(c => c.owned);
    const missingCards = allCards.filter(c => !c.owned);
    const ownedValue = ownedCards.reduce((s, c) => s + (parseFloat(c[priceField]) || 0) * c.qty, 0);
    const modeLabel = includeUnowned === 'full' ? 'full' : 'base';
    statusEl.textContent = `${ownedCards.length} owned, ${missingCards.length} missing (${modeLabel}) \u2014 ${priceLabel} $${ownedValue.toFixed(2)}`;
  } else {
    const totalQty = allCards.reduce((s, c) => s + c.qty, 0);
    const totalValue = allCards.reduce((s, c) => s + (parseFloat(c[priceField]) || 0) * c.qty, 0);
    statusEl.textContent = `${allCards.length} entries, ${totalQty} cards \u2014 ${priceLabel} $${totalValue.toFixed(2)}`;
  }
}

async function fetchCollection() {
  updateUnownedBtn();
  const params = getFetchParams();
  statusEl.textContent = 'Loading...';
  const res = await fetch(`/api/collection?${params}`);
  allCardsUnfiltered = await res.json();
  selectedCards.clear();
  lastSelectedIdx = null;
  updateSelectionBar();

  // Populate set/subtype options from unfiltered data
  populateSetOptions();
  populateSubtypeOptions();

  // All filtering + sorting happens client-side
  allCards = applyClientSort(applyAllClientFilters([...allCardsUnfiltered]));
  updateStatusText();
  render();
}

function populateSetOptions() {
  const sets = new Map();
  // Include all cached sets so users can browse sets they don't own cards from
  for (const s of cachedSets) {
    sets.set(s.code, s.name);
  }
  // Overlay with sets from current data (ensures owned sets always appear)
  for (const card of allCardsUnfiltered) {
    if (!sets.has(card.set_code)) {
      sets.set(card.set_code, card.set_name);
    }
  }
  allSetOptions = Array.from(sets.entries())
    .map(([code, name]) => ({ code, name }))
    .sort((a, b) => a.name.localeCompare(b.name));
}

function populateSubtypeOptions() {
  const subtypes = new Set();
  for (const card of allCardsUnfiltered) {
    const tl = card.type_line || '';
    const dashIdx = tl.indexOf(' \u2014 ');
    if (dashIdx !== -1) {
      const sub = tl.substring(dashIdx + 3);
      for (const s of sub.split(/\s+/)) {
        if (s) subtypes.add(s);
      }
    }
  }
  allSubtypeOptions = Array.from(subtypes).sort();
}

// --- Render ---
function render() {
  if (currentView === 'table') renderTable();
  else renderGrid();
}

const CONDITION_ABBREV = {
  'Near Mint': 'NM', 'Lightly Played': 'LP', 'Moderately Played': 'MP',
  'Heavily Played': 'HP', 'Damaged': 'D',
};

function formatDate(iso) {
  if (!iso) return '';
  const d = new Date(iso);
  const m = d.getMonth() + 1, day = d.getDate();
  return `${m}/${day}`;
}

function renderCellContent(colKey, card, helpers) {
  switch (colKey) {
    case 'qty': return card.owned ? `${card.qty}` : '\u2014';
    case 'name': return `<div class="card-cell">${helpers.imgSrc ? `<img class="card-thumb" src="${helpers.imgSrc}" loading="lazy">` : ''}<span class="filterable" data-filter-type="name" data-filter-value="${(card.name.split(' // ')[0]).replace(/"/g, '&quot;')}">${helpers.nameHtml}${helpers.tags}</span></div>`;
    case 'type': {
      if (card.layout === 'art_series') return `<span class="type-cell" title="Art Series">Art Series</span>`;
      const full = card.type_line || '';
      const faces = full.split(' // ');
      return `<span class="type-cell" title="${full}">${faces.map(face => {
        const parts = face.split(' \u2014 ');
        const mainText = parts[0];
        const main = mainText.replace(/Legendary /g, 'Lgdry. ');
        const primaryType = getPrimaryType(mainText);
        const mainHtml = primaryType ? `<span class="filterable" data-filter-type="type" data-filter-value="${primaryType}">${main}</span>` : main;
        const sub = parts[1] || '';
        const subHtml = sub ? `<span class="type-sub">${sub.split(/\s+/).map(s => s ? `<span class="filterable" data-filter-type="subtype" data-filter-value="${s}">${s}</span>` : '').join(' ')}</span>` : '';
        return `<span class="card-face">${mainHtml}${subHtml}</span>`;
      }).join('')}</span>`;
    }
    case 'mana': return card.cmc != null ? `<span class="mana-cost filterable" data-filter-type="cmc" data-filter-value="${card.cmc}">${helpers.manaHtml}</span>` : `<span class="mana-cost">${helpers.manaHtml}</span>`;
    case 'set': return `<div class="set-cell" title="${helpers.setName}"><span class="filterable" data-filter-type="rarity" data-filter-value="${card.rarity || 'common'}">${helpers.setIcon}</span> <span class="filterable" data-filter-type="set" data-filter-value="${card.set_code}">${card.set_code.toUpperCase()}</span></div>`;
    case 'collector_number': return (card.collector_number || '').padStart(4, '0');
    case 'price': return buildPriceBadges(card);
    case 'condition': return CONDITION_ABBREV[card.condition] || card.condition || '';
    case 'date_added': {
      const dateStr = formatDate(card.acquired_at);
      if (!dateStr) return '';
      const isoDate = card.acquired_at.slice(0, 10);
      return `<span class="filterable" data-filter-type="date_added" data-filter-value="${isoDate}">${dateStr}</span>`;
    }
    case 'ck_price': {
      const p = card.ck_price ? `$${parseFloat(card.ck_price).toFixed(2)}` : '';
      return p ? `<a class="badge link" href="${getCkUrl(card)}" target="_blank" rel="noopener" onclick="event.stopPropagation()">${p}</a>` : '';
    }
    case 'tcg_price': {
      const p = card.tcg_price ? `$${parseFloat(card.tcg_price).toFixed(2)}` : '';
      return p ? `<a class="badge link" href="https://scryfall.com/card/${card.set_code.toLowerCase()}/${card.collector_number}" target="_blank" rel="noopener" onclick="event.stopPropagation()">${p}</a>` : '';
    }
    default: return '';
  }
}

function renderTable() {
  if (allCards.length === 0) {
    main.innerHTML = '<div class="empty-state">No cards found</div>';
    return;
  }

  const visCols = getVisibleColumns();

  let html = '<table class="collection-table"><thead><tr>';
  if (multiSelectMode) {
    const allChecked = selectedCards.size === allCards.length && allCards.length > 0;
    html += `<th class="select-col"><input type="checkbox" class="sel-all-cb" ${allChecked ? 'checked' : ''}></th>`;
  }
  for (const col of visCols) {
    const isActive = col.key === sortColumn;
    const arrow = isActive ? `<span class="sort-arrow">${sortOrder === 'asc' ? '\u25B2' : '\u25BC'}</span>` : '';
    html += `<th class="${isActive ? 'sorted' : ''}" data-col="${col.key}">${col.label}${arrow}</th>`;
  }
  html += '</tr></thead><tbody>';

  for (let idx = 0; idx < allCards.length; idx++) {
    const card = allCards[idx];
    const imgFull = card.image_uri || '';
    const imgSrc = imgFull.replace('/normal/', '/small/');
    const rawMana = card.mana_cost || '';
    const isArtSeries = card.layout === 'art_series';
    const isDfc = !isArtSeries && card.name.includes(' // ');
    let displayName = isArtSeries ? card.name.split(' // ')[0] : card.name;
    let nameHtml, manaHtml;
    if (isDfc) {
      const names = card.name.split(' // ');
      const manas = rawMana.split(' // ');
      nameHtml = names.map(n => `<span class="card-face"><span class="card-name">${n}</span></span>`).join('');
      manaHtml = manas.map(m => `<span class="mana-line">${renderMana(m)}</span>`).join('');
    } else {
      nameHtml = `<span class="card-name">${displayName}</span>`;
      manaHtml = renderMana(rawMana);
    }
    const setCode = keyruneSetCode(card.set_code);
    const rarityClass = `ss-${card.rarity || 'common'}`;
    const setName = card.set_name || card.set_code.toUpperCase();
    const setIcon = `<i class="ss ss-${setCode} ${rarityClass} ss-grad"></i>`;
    const tags = buildInlineTags(card);
    const helpers = { imgSrc, nameHtml, manaHtml, setCode, setName, setIcon, tags };

    const isSelected = selectedCards.has(idx);
    const isUnowned = !card.owned;
    const isWanted = isCardWanted(card);
    const isOrdered = card.status === 'ordered';
    const trClasses = [isSelected ? 'selected' : '', isUnowned ? 'unowned' : '', isUnowned && isWanted ? 'wanted' : '', isOrdered ? 'ordered' : ''].filter(Boolean).join(' ');
    html += `<tr data-idx="${idx}"${trClasses ? ` class="${trClasses}"` : ''}>`;
    if (multiSelectMode) {
      html += `<td class="select-col"><input type="checkbox" class="row-sel-cb" data-idx="${idx}" ${isSelected ? 'checked' : ''}></td>`;
    }
    for (const col of visCols) {
      const cls = col.key === 'price' || col.key === 'ck_price' || col.key === 'tcg_price' ? ' class="price-cell"' : '';
      html += `<td${cls}>${renderCellContent(col.key, card, helpers)}</td>`;
    }
    html += '</tr>';
  }

  html += '</tbody></table>';
  main.innerHTML = html;

  // Delegated click handler for checkboxes, filterable elements and row->modal
  main.querySelector('.collection-table').addEventListener('click', (e) => {
    // Select-all checkbox
    if (e.target.classList.contains('sel-all-cb')) {
      if (e.target.checked) {
        for (let i = 0; i < allCards.length; i++) selectedCards.add(i);
      } else {
        selectedCards.clear();
      }
      updateSelectionBar();
      render();
      return;
    }
    // Per-row checkbox
    if (e.target.classList.contains('row-sel-cb')) {
      const idx = parseInt(e.target.dataset.idx);
      toggleCardSelection(idx, e.shiftKey);
      if (e.shiftKey) { render(); return; }
      e.target.closest('tr').classList.toggle('selected', selectedCards.has(idx));
      // Update select-all checkbox state
      const allCb = main.querySelector('.sel-all-cb');
      if (allCb) allCb.checked = selectedCards.size === allCards.length;
      return;
    }
    // External links pass through
    if (e.target.closest('a')) return;
    // Filterable element click
    const filterEl = e.target.closest('[data-filter-type]');
    if (filterEl) {
      e.stopPropagation();
      applyFilter(filterEl.dataset.filterType, filterEl.dataset.filterValue);
      return;
    }
    // Row click -> modal
    const tr = e.target.closest('tr[data-idx]');
    if (tr) showCardModal(allCards[parseInt(tr.dataset.idx)]);
  });

  // Column header click sorting
  main.querySelectorAll('.collection-table th[data-col]').forEach(th => {
    th.addEventListener('click', () => handleSortClick(th.dataset.col));
  });
}

function renderGrid() {
  if (allCards.length === 0) {
    main.innerHTML = '<div class="empty-state">No cards found</div>';
    return;
  }

  // Sort bar
  const bar = document.createElement('div');
  bar.className = 'sort-bar';
  for (const col of ALL_COLUMNS) {
    const btn = document.createElement('span');
    btn.className = 'sort-btn' + (col.key === sortColumn ? ' active' : '');
    const arrow = col.key === sortColumn ? ` ${sortOrder === 'asc' ? '\u25B2' : '\u25BC'}` : '';
    btn.textContent = col.label + arrow;
    btn.addEventListener('click', () => handleSortClick(col.key));
    bar.appendChild(btn);
  }

  const grid = document.createElement('div');
  grid.className = 'card-grid';

  for (let idx = 0; idx < allCards.length; idx++) {
    const card = allCards[idx];
    const isUnowned = !card.owned;
    const isWanted = isUnowned && isCardWanted(card);
    const cardEl = document.createElement('div');
    const isOrdered = card.status === 'ordered';
    cardEl.className = 'sheet-card' + (isUnowned ? ' unowned' : '') + (isWanted ? ' wanted' : '') + (isOrdered ? ' ordered' : '');

    const rarityColor = getRarityColor(card.rarity);
    const foilClass = (!isUnowned && (card.finish === 'foil' || card.finish === 'etched')) ? ' foil' : '';
    const qtyBadge = !isUnowned && card.qty > 1 ? `<span class="qty-badge">${card.qty}x</span>` : '';
    const wantedBadge = isWanted ? '<span class="wanted-badge">Want</span>' : '';
    const orderedBadge = card.status === 'ordered' ? '<span class="ordered-badge" title="Ordered"></span>' : '';
    const selectCb = multiSelectMode ? `<input type="checkbox" class="select-checkbox" data-idx="${idx}" ${selectedCards.has(idx) ? 'checked' : ''}>` : '';

    cardEl.innerHTML = `
      <div class="sheet-card-img-wrap${foilClass}" style="--rarity-color:${rarityColor};--set-color:#111">
        <img src="${card.image_uri || ''}" alt="${card.name}" loading="lazy">
        ${qtyBadge}
        ${wantedBadge}
        ${orderedBadge}
        ${selectCb}
      </div>
    `;
    cardEl.addEventListener('click', (e) => {
      if (e.target.classList.contains('select-checkbox')) {
        toggleCardSelection(idx, e.shiftKey);
        if (e.shiftKey) render();
        return;
      }
      showCardModal(card);
    });
    grid.appendChild(cardEl);
  }

  main.innerHTML = '';
  main.appendChild(bar);
  main.appendChild(grid);
}

// --- Event listeners ---
// Search input is the only filter that triggers a backend fetch
searchInput.addEventListener('input', () => {
  clearTimeout(debounceTimer);
  debounceTimer = setTimeout(fetchCollection, 300);
});

// All other filters are client-side — instant refilter, no fetch
document.querySelectorAll('#color-filters input, #rarity-filters input, #finish-filters input, #badge-filters input, #type-filters input, #status-filters input').forEach(cb => {
  cb.addEventListener('change', refilterAndRender);
});

const debouncedRefilter = () => {
  clearTimeout(debounceTimer);
  debounceTimer = setTimeout(refilterAndRender, 150);
};
cnMinEl.addEventListener('input', debouncedRefilter);
cnMaxEl.addEventListener('input', debouncedRefilter);
cmcMinEl.addEventListener('input', debouncedRefilter);
cmcMaxEl.addEventListener('input', debouncedRefilter);
priceMinEl.addEventListener('input', debouncedRefilter);
priceMaxEl.addEventListener('input', debouncedRefilter);
dateMinEl.addEventListener('input', debouncedRefilter);
dateMaxEl.addEventListener('input', debouncedRefilter);

clearFiltersBtn.addEventListener('click', () => {
  document.querySelectorAll('#color-filters input, #rarity-filters input, #finish-filters input, #badge-filters input, #type-filters input, #status-filters input').forEach(cb => {
    cb.checked = false;
  });
  selectedSets.clear();
  selectedSubtypes.clear();
  includeUnowned = '';
  updateUnownedBtn();
  setMultiSelect.renderPills();
  subtypeMultiSelect.renderPills();
  searchInput.value = '';
  cnMinEl.value = '';
  cnMaxEl.value = '';
  cmcMinEl.value = '';
  cmcMaxEl.value = '';
  priceMinEl.value = '';
  priceMaxEl.value = '';
  dateMinEl.value = '';
  dateMaxEl.value = '';
  fetchCollection();
});

function applySettings() {
  const style = document.getElementById('dynamic-settings-style');
  let css = '';
  if (_settings.image_display === 'contain') {
    css += '.card-thumb { width: 36px; height: 50px; object-fit: contain !important; object-position: center !important; }\n';
    css += '.sheet-card-img-wrap img { object-fit: contain !important; object-position: center !important; }\n';
  }
  style.textContent = css;
}

// --- Wishlist state ---
async function loadWishlist() {
  const res = await fetch('/api/wishlist?fulfilled=false');
  const entries = await res.json();
  wishlistMap = {};
  wishlistByScryfall = {};
  wishlistByOracle = {};
  for (const e of entries) _addWishlistEntry(e);
  updateWishlistCount();
}

function updateWishlistCount() {
  const n = Object.keys(wishlistMap).length;
  const btn = document.getElementById('wishlist-toggle-btn');
  if (btn) btn.textContent = `Wishlist (${n})`;
}


function renderWishlistPanel() {
  const list = document.getElementById('wishlist-panel-list');
  const entries = Object.values(wishlistMap);
  if (entries.length === 0) {
    list.innerHTML = '<div class="empty-state" style="padding:16px">Wishlist is empty</div>';
    return;
  }
  list.innerHTML = entries.map(e => {
    const setLabel = e.set_code ? ` <span class="wl-set">${e.set_code.toUpperCase()}</span>` : '';
    const cnLabel = e.collector_number ? ` <span class="wl-set">#${e.collector_number}</span>` : '';
    return `<div class="wl-entry" data-wl-id="${e.id}" data-scryfall-id="${e.scryfall_id || ''}" style="cursor:pointer">
      <span class="wl-name">${(e.name || '').split(' // ')[0]}${setLabel}${cnLabel}</span>
      <button class="wl-remove" title="Remove">&times;</button>
    </div>`;
  }).join('');
}

function toggleWishlistPanel(open) {
  const panel = document.getElementById('wishlist-panel');
  const backdrop = document.getElementById('wishlist-backdrop');
  if (open === undefined) open = !panel.classList.contains('open');
  panel.classList.toggle('open', open);
  backdrop.classList.toggle('active', open);
  if (open) renderWishlistPanel();
}

// Wishlist panel events
document.getElementById('wishlist-toggle-btn').addEventListener('click', () => toggleWishlistPanel());
document.getElementById('wishlist-close').addEventListener('click', () => toggleWishlistPanel(false));
document.getElementById('wishlist-backdrop').addEventListener('click', () => toggleWishlistPanel(false));

document.getElementById('wishlist-panel-list').addEventListener('click', async (e) => {
  const removeBtn = e.target.closest('.wl-remove');
  const entryEl = e.target.closest('.wl-entry');
  if (!entryEl) return;

  if (removeBtn) {
    // Remove from wishlist
    const wlId = parseInt(entryEl.dataset.wlId);
    await fetch(`/api/wishlist/${wlId}`, { method: 'DELETE' });
    const wl = wishlistMap[wlId];
    if (wl) _removeWishlistEntry(wl);
    updateWishlistCount();
    renderWishlistPanel();
    return;
  }

  // Click on entry name — open card modal
  const scryfallId = entryEl.dataset.scryfallId;
  if (!scryfallId) return;
  const card = allCards.find(c => c.scryfall_id === scryfallId);
  if (card) {
    toggleWishlistPanel(false);
    showCardModal(card);
  } else {
    // Card not in current view — fetch from API
    const res = await fetch(`/api/card/${scryfallId}`);
    if (res.ok) {
      const cardData = await res.json();
      toggleWishlistPanel(false);
      showCardModal(cardData);
    }
  }
});

document.getElementById('wl-copy-ck').addEventListener('click', () => {
  const entries = Object.values(wishlistMap);
  if (!entries.length) return;
  copyAndOpen(buildCKList(entries), 'https://www.cardkingdom.com/builder');
});

document.getElementById('wl-copy-tcg').addEventListener('click', () => {
  const entries = Object.values(wishlistMap);
  if (!entries.length) return;
  copyAndOpen(buildTCGList(entries), 'https://www.tcgplayer.com/massentry');
});

document.getElementById('wl-clear-all').addEventListener('click', async () => {
  const entries = Object.values(wishlistMap);
  if (!entries.length) return;
  if (!confirm(`Remove all ${entries.length} wishlist entries?`)) return;
  for (const e of entries) {
    await fetch(`/api/wishlist/${e.id}`, { method: 'DELETE' });
  }
  wishlistMap = {};
  wishlistByScryfall = {};
  wishlistByOracle = {};
  updateWishlistCount();
  renderWishlistPanel();
});

// --- Buy Missing ---
const buyMissingBtn = document.getElementById('buy-missing-btn');
const buyMissingDropdown = document.getElementById('buy-missing-dropdown');

buyMissingBtn.addEventListener('click', (e) => {
  e.stopPropagation();
  buyMissingDropdown.classList.toggle('open');
});

document.addEventListener('click', (e) => {
  if (!buyMissingDropdown.contains(e.target) && e.target !== buyMissingBtn) {
    buyMissingDropdown.classList.remove('open');
  }
});

function getUnownedCards() {
  // If multi-select active with selections, use only selected unowned cards
  if (multiSelectMode && selectedCards.size > 0) {
    return Array.from(selectedCards).map(i => allCards[i]).filter(c => !c.owned);
  }
  return allCards.filter(c => !c.owned);
}

document.getElementById('buy-missing-ck').addEventListener('click', () => {
  buyMissingDropdown.classList.remove('open');
  const cards = getUnownedCards();
  if (!cards.length) { alert('No unowned cards in current view'); return; }
  copyAndOpen(buildCKList(cards), 'https://www.cardkingdom.com/builder');
});

document.getElementById('buy-missing-tcg').addEventListener('click', () => {
  buyMissingDropdown.classList.remove('open');
  const cards = getUnownedCards();
  if (!cards.length) { alert('No unowned cards in current view'); return; }
  copyAndOpen(buildTCGList(cards), 'https://www.tcgplayer.com/massentry');
});

// --- Cart text builders ---
function buildCKList(cards) {
  return cards.map(c => `1 ${(c.name || '').split(' // ')[0]}`).join('\n');
}

function buildTCGList(cards) {
  return cards.map(c => {
    const name = (c.name || '').split(' // ')[0];
    if (c.set_code && c.collector_number) {
      return `1 ${name} [${c.set_code.toUpperCase()}] ${c.collector_number}`;
    }
    return `1 ${name}`;
  }).join('\n');
}

async function copyAndOpen(text, url) {
  await navigator.clipboard.writeText(text);
  window.open(url, '_blank');
}

// --- Init ---
(async () => {
  const [settingsRes, cachedSetsRes, _] = await Promise.all([
    fetch('/api/settings'),
    fetch('/api/cached-sets'),
    loadWishlist(),
  ]);
  _settings = await settingsRes.json();
  cachedSets = await cachedSetsRes.json();
  applySettings();
  fetchCollection();
})();
</script>

</body>
</html>
